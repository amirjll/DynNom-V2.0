{
    "collab_server" : "",
    "contents" : "if (getRversion() >= \"2.15.1\") utils::globalVariables(c(\"counter\", \"Prediction\",\n                                                        \"input.data\", \"old.d\"))\n\nDynNom.lm <- function(model, data,\n                      clevel = 0.95, covariate = c(\"slider\", \"numeric\")) {\n\n  data <- data.frame(data)\n\n  if (length(dim(data)) > 2)\n    stop(\"Error in data format: dataframe format required\")\n\n  if (attr(model$terms, \"dataClasses\")[[1]] == \"logical\")\n    stop(\"Error in model syntax: logical form for response not supported\")\n\n  if (tail(names(attr(model$terms,\"dataClasses\")),n=1)==\"(weights)\") {\n    n.terms <- length(attr(model$terms,\"dataClasses\"))\n    attr(model$terms,\"dataClasses\") <- attr(model$terms,\"dataClasses\")[1:n.terms - 1]\n  }\n\n  for(i in 1:length(names(attr(model$terms, \"dataClasses\")))) {\n    com1=numeric(length(names(data)))\n    for(j in 1:length(names(data))) {\n      if (names(attr(model$terms, \"dataClasses\"))[i]==names(data)[j]) com1[j]=1\n    }\n    if (sum(com1)==0)\n      stop(\"Error in model syntax: some of model's terms do not match to variables' name in dataset\")\n  }\n\n  covariate <- match.arg(covariate)\n  input.data <- NULL\n  old.d <- NULL\n\n  runApp(list(\n\n    ui = bootstrapPage(fluidPage(\n      titlePanel(\"Dynamic Nomogram\"),\n      sidebarLayout(sidebarPanel(uiOutput(\"manySliders.f\"),\n                                 uiOutput(\"manySliders.n\"),\n                                 checkboxInput(\"limits\", \"Set x-axis ranges\"),\n                                 conditionalPanel(condition = \"input.limits == true\",\n                                                  numericInput(\"uxlim\", \"x-axis lower\", NA),\n                                                  numericInput(\"lxlim\", \"x-axis upper\", NA)),\n                                 actionButton(\"add\", \"Predict\"),\n                                 br(), br(),\n                                 helpText(\"Press Quit to exit the application\"),\n                                 actionButton(\"quit\", \"Quit\")\n      ),\n      mainPanel(tabsetPanel(id = \"tabs\",\n                            tabPanel(\"Graphical Summary\", plotOutput(\"plot\")),\n                            tabPanel(\"Numerical Summary\", verbatimTextOutput(\"data.pred\")),\n                            tabPanel(\"Model Summary\", verbatimTextOutput(\"summary\"))\n      )\n      )\n      ))),\n\n    server = function(input, output){\n\n      q <- observe({\n        if (input$quit == 1)\n          stopApp()\n      })\n\n      limits0 <- c(mean(as.numeric(model$model[[1]])) - 3 * sd(model$model[[1]]),\n                   mean(as.numeric(model$model[[1]])) + 3 * sd(model$model[[1]]))\n      limits <- reactive({\n        if (as.numeric(input$limits) == 1) {\n          limits <- c(input$lxlim, input$uxlim)\n        } else {\n          limits <- limits0\n        }\n      })\n\n      neededVar <- names(attr(model$terms, \"dataClasses\"))\n      data <- data[, neededVar]\n      input.data <<- data[1, ]\n      input.data[1, ] <<- NA\n\n      b <- 1\n      i.factor <- NULL\n      i.numeric <- NULL\n      for (j in 2:length(attr(model$terms, \"dataClasses\"))) {\n        for (i in 1:length(data)) {\n          if (names(attr(model$terms, \"dataClasses\"))[j] == names(data)[i]) {\n            if (attr(model$terms, \"dataClasses\")[[j]] == \"factor\" |\n                attr(model$terms, \"dataClasses\")[[j]] == \"ordered\" |\n                attr(model$terms, \"dataClasses\")[[j]] == \"logical\") {\n              i.factor <- rbind(i.factor, c(names(attr(model$terms, \"dataClasses\"))[j], j, i, b))\n              (break)()\n            }\n            if (attr(model$terms, \"dataClasses\")[[j]] == \"numeric\") {\n              i.numeric <- rbind(i.numeric, c(names(attr(model$terms, \"dataClasses\"))[j], j, i))\n              b <- b + 1\n              (break)()\n            }\n          }\n        }\n      }\n\n      nn <- nrow(i.numeric)\n      if (is.null(nn)) {\n        nn <- 0\n      }\n      nf <- nrow(i.factor)\n      if (is.null(nf)) {\n        nf <- 0\n      }\n\n      if (nf > 0) {\n        output$manySliders.f <- renderUI({\n          slide.bars <- list(lapply(1:nf, function(j) {\n            selectInput(paste(\"factor\", j, sep = \"\"),\n                        names(attr(model$terms, \"dataClasses\")[as.numeric(i.factor[j, 2])]),\n                        model$xlevels[[as.numeric(i.factor[j, 2]) - as.numeric(i.factor[j, 4])]], multiple = FALSE)\n          }))\n          do.call(tagList, slide.bars)\n        })\n      }\n\n      if (nn > 0) {\n        output$manySliders.n <- renderUI({\n          if (covariate == \"slider\") {\n            slide.bars <- list(lapply(1:nn, function(j) {\n              sliderInput(paste(\"numeric\", j, sep = \"\"),\n                          names(attr(model$terms, \"dataClasses\")[as.numeric(i.numeric[j, 2])]),\n                          min = as.integer(min(na.omit(data[, as.numeric(i.numeric[j, 3])]))),\n                          max = as.integer(max(na.omit(data[, as.numeric(i.numeric[j, 3])]))) + 1,\n                          value = as.integer(mean(na.omit(data[, as.numeric(i.numeric[j, 3])]))))\n            }))\n          }\n          if (covariate == \"numeric\") {\n            slide.bars <- list(lapply(1:nn, function(j) {\n              numericInput(paste(\"numeric\", j, sep = \"\"),\n                           names(attr(model$terms, \"dataClasses\")[as.numeric(i.numeric[j, 2])]),\n                           value = as.integer(mean(na.omit(data[, as.numeric(i.numeric[j, 3])]))))\n            }))\n          }\n          do.call(tagList, slide.bars)\n        })\n      }\n\n      a <- 0\n      new.d <- reactive({\n        if (nf > 0) {\n          input.f <- vector(\"list\", nf)\n          for (i in 1:nf) {\n            input.f[[i]] <- local({\n              input[[paste(\"factor\", i, sep = \"\")]]\n            })\n            names(input.f)[i] <- i.factor[i, 1]\n          }\n        }\n        if (nn > 0) {\n          input.n <- vector(\"list\", nn)\n          for (i in 1:nn) {\n            input.n[[i]] <- local({\n              input[[paste(\"numeric\", i, sep = \"\")]]\n            })\n            names(input.n)[i] <- i.numeric[i, 1]\n          }\n        }\n        if (nn == 0) {\n          out <- data.frame(do.call(\"cbind\", input.f))\n        }\n        if (nf == 0) {\n          out <- data.frame(do.call(\"cbind\", input.n))\n        }\n        if (nf > 0 & nn > 0) {\n          out <- data.frame(do.call(\"cbind\", input.f), do.call(\"cbind\", input.n))\n        }\n        if (a == 0) {\n          wher <- match(names(out), names(input.data)[-1])\n          out <- out[wher]\n          input.data <<- rbind(input.data[-1], out)\n        }\n        if (a > 0) {\n          wher <- match(names(out), names(input.data))\n          out <- out[wher]\n          input.data <<- rbind(input.data, out)\n        }\n        a <<- a + 1\n        out\n      })\n\n      p1 <- NULL\n      old.d <- NULL\n      data2 <- reactive({\n        if (input$add == 0)\n          return(NULL)\n        if (input$add > 0) {\n          if (isTRUE(compare(old.d, new.d())) == FALSE) {\n            OUT <- isolate({\n              pred <- predict(model, newdata = new.d(), conf.int = clevel,\n                              se.fit = TRUE)\n              lwb <- pred$fit - (qt(1 - (1 - clevel)/2, model$df.residual) * pred$se.fit)\n              upb <- pred$fit + (qt(1 - (1 - clevel)/2, model$df.residual) * pred$se.fit)\n              d.p <- data.frame(Prediction = pred$fit, Lower.bound = lwb, Upper.bound = upb)\n              old.d <<- new.d()\n              data.p <- cbind(d.p, counter = 1)\n              p1 <<- rbind(p1, data.p)\n              p1$count <- seq(1, dim(p1)[1])\n              p1\n            })\n          } else {\n            p1$count <- seq(1, dim(p1)[1])\n            OUT <- p1\n          }\n        }\n        OUT\n      })\n\n      output$plot <- renderPlot({\n        if (input$add == 0)\n         return(NULL)\n        OUT <- isolate({\n          if (is.null(new.d()))\n            return(NULL)\n          if (is.na(input$lxlim) | is.na(input$uxlim)) {\n            lim <- limits0\n          } else {\n            lim <- limits()\n          }\n          yli <- c(0 - 0.5, 10 + 0.5)\n          if (dim(input.data)[1] > 11)\n            yli <- c(dim(input.data)[1] - 11.5, dim(input.data)[1] - 0.5)\n          p <- ggplot(data = data2(), aes(x = Prediction, y = 0:(sum(counter) - 1)))\n          p <- p + geom_point(size = 4, colour = data2()$count, shape = 15)\n          p <- p + ylim(yli[1], yli[2]) + coord_cartesian(xlim = lim)\n          p <- p + geom_errorbarh(xmax = data2()$Upper.bound, xmin = data2()$Lower.bound,\n                                  size = 1.45, height = 0.4, colour = data2()$count)\n          p <- p + labs(title = paste(clevel * 100, \"% \", \"Confidence Interval for Response\", sep = \"\"),\n                        x = \"Response\", y = NULL)\n          p <- p + theme_bw() + theme(axis.text.y = element_blank(), text = element_text(face = \"bold\", size = 14))\n          print(p)\n        })\n        OUT\n      })\n\n      output$data.pred <- renderPrint({\n        if (input$add > 0) {\n          OUT <- isolate({\n            if (nrow(data2() > 0)) {\n              if (dim(input.data)[2] == 1) {\n                in.d <- data.frame(input.data[-1, ])\n                names(in.d) <- names(attr(model$terms, \"dataClasses\"))[2]\n                data.p <- cbind(in.d, data2()[1:3])\n              }\n              if (dim(input.data)[2] > 1) {\n                data.p <- cbind(input.data[-1, ], data2()[1:3])\n              }\n              stargazer(data.p, summary = FALSE, type = \"text\")\n            }\n          })\n        }\n      })\n\n      output$summary <- renderPrint({\n        stargazer(model, type = \"text\", omit.stat = c(\"LL\", \"ser\", \"f\"), ci = TRUE, ci.level = clevel,\n                  single.row = TRUE, title = paste(\"Linear Regression:\", model$call[2], sep = \" \"))\n      })\n    }\n  )\n  )\n}\n",
    "created" : 1473851550502.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4035913349",
    "id" : "74793C3F",
    "lastKnownWriteTime" : 1446031107,
    "last_content_update" : 1446031107,
    "path" : "C:/Users/Amir/Dropbox/Projects/DynNom project/DynNom V2.0/DynNom/R/DynNom_lm.R",
    "project_path" : "R/DynNom_lm.R",
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}